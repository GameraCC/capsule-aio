'use strict';

const { app, BrowserWindow, BrowserView, session, TouchBarSlider } = require('electron')
const path = require('path')
const url = require('url')
const axios = require('axios')
const puppeteer = require('puppeteer-extra')
const StealthPlugin = require('puppeteer-extra-plugin-stealth')()

// Remove user agent evasion, puppeteer user agent override only replaces headless from user agent, not electron.
// createNewDefaultSession (puppeteer) uses different userAgent than electron
StealthPlugin.enabledEvasions.delete('user-agent-override')
puppeteer.use(StealthPlugin)

const { createCursor } = require('./ghost-cursor/lib/spoof.js')
const crypto = require('crypto')
const random = require('random')
const seedrandom = require('seedrandom')
const ProxyChain = require('proxy-chain')
const getPort = require('get-port')
const EventEmitter = require('events');
const Jimp = require('jimp').default
const pixelMatch = require('pixelmatch')

/* 
    This opencv version is not the default packaged opencv.js from their releases, The
    latter uses a callback to determine when the library's WASM is ready at runtime,
    whereas the former uses async promises to determine runtime initialization instead

    This version is built on Ubuntu 18.04 LTS with solely a build directory argument
*/
let openCvRuntimeInitialized = false, cv

try {
    cv = require('./opencv.js')
} catch (err) {
    console.error('[ERROR] Error Initializing OpenCV In Solver')
}

cv.then(_cv => {
    openCvRuntimeInitialized = true
    cv = _cv
}).catch((err) => {
    console.error('[ERROR] OpenCV Caught Error')
})

const RECAPTCHA_V3_INVISIBLE_TEST_URL = 'https://recaptcha-demo.appspot.com/recaptcha-v3-request-scores.php'
const RECAPTCHA_V2_VISIBLE_TEST_URL = 'https://patrickhlauke.github.io/recaptcha'
const GOOGLE_ACCOUNT_LOGIN_URL = 'https://accounts.google.com'
const DEFAULT_GOOGLE_URL = 'https://www.google.com'

const DEFAULT_CAPTCHA_SOLVER_WIDTH = 400
const DEFAULT_CAPTCHA_SOLVER_HEIGHT = 500

let DEFAULT_CAPTCHA_WINDOW_CONTENT = `
<!DOCTYPE html> <html style="background-color: #191E28;"> <head> <title>Captcha Solver</title> <style> @font-face { font-family: 'Alt Regular'; font-style: normal; font-weight: normal; src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2'); } </style> </head> <body style="overflow: hidden; user-select: none"> <div style="display: flex; align-items: center; justify-content: center; height: 500px; width: 100%"> <svg xmlns="http://www.w3.org/2000/svg" width="286.91px" height="286.91px" viewBox="0 0 286.91 286.91"> <path id="spinner" fill="#D1AAFF" d="M143.46,0C105.3,0,69.32,14.97,42.15,42.15C14.97,69.32,0,105.3,0,143.46c0,38.15,14.97,74.13,42.15,101.31 c27.18,27.18,63.16,42.15,101.31,42.15c1.56,0,2.87-1.32,2.87-2.87s-1.32-2.87-2.87-2.87c-75.93,0-137.71-61.78-137.71-137.71 S67.52,5.74,143.46,5.74s137.71,61.78,137.71,137.71c0,1.56,1.32,2.87,2.87,2.87s2.87-1.32,2.87-2.87 c0-38.15-14.97-74.13-42.15-101.31S181.61,0,143.46,0z" > <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 143.455 143.455" to="360 143.455 143.455" dur="2s" repeatCount="indefinite" /> </path> </svg> <span style="position: absolute; font-size: 16px; color: #fff; font-family: 'Alt Regular', sans-serif">Waiting for Captcha</span> </div> </body> </html>
`

const DEFAULT_CAPTCHA_SOLVER_USER_AGENT = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4427.0 Safari/537.36'

/**
 * Used to determine what to intercept when intercepting responses and requests
 *
 * @typedef {Object} Interception
 *
 * @property {boolean} [regex=true] - Whether or not to use a regex as the string, this value is only interpereted if false
 * @property {boolean} [stop=false] - Whether or not to fail the request upon interception
 * @property {RegExp | string} url - Regex of the url to match an interception to
 * @property {?string} content - Content to replace an intercepted request with
 * @property {?string} contentType - Content type of the content when intercepting a request
 */

/**
 * @typedef {Object} Session
 *
 * @property {?string} name - Name of the session
 * @property {string} id - Id of the session
 * @property {Object} cookies - Object containing cookie data regarding the session
 * @property {Object} localStorage - Object containing local storage data regarding the session
 * @property {Object} sessionStorage - Object containing session storage data regarding the session
 */

/**
 * @typedef {Object} Solver
 *
 * @property {string} sessionId - Session being used with the solver
 * @property {string} originalSessionId - Id of session which was created with the solver
 * @property {?string} proxy - Proxy used with the solver
 * @property {?boolean} autoClickCaptcha - Whether or not the solver's captchas should be auto clicked
 */

/**
 * @typedef {Object} WindowInfo
 *
 * @property {string} id - Id of the window
 * @property {"main" | "satellite"} type - Type of window
 * @property {Object} window - Electron BrowserWindow object used to control the BrowserWindow
 * @property {number} height - Height for BrowserViews
 * @property {number} width - Width for BrowserViews
 * @property {number} offsetX - X offset for BrowserViews
 * @property {number} offsetY - Y offset for BrowserViews
 */

/**
 * @typedef {Object} SolverInfo
 *
 * @property {string} id - Id of the solver
 * @property {Object} page - Puppeteer page object used to control the page
 * @property {Object} view - Electron BrowserView object used to control the BrowserView
 * @property {WindowInfo} window - Window being used with the solver
 * @property {Session} session - Session being used with the solver
 * @property {string} originalSessionId - Id of session which was created with the solver
 * @property {Object} proxy - Proxy server used by the page
 * @property {Function} proxy.rotate - Used to rotate the proxy used by the page
 * @property {{host: string, port: number, username: string | undefined, password: string | undefined}} proxy.current - Current proxy being used by the page
 * @property {boolean} autoClickCaptcha - Whether or not the solver's captchas should be auto clicked
 * @property {Object} usage - Usage info about the solver
 * @property {boolean} usage.available - Whether or not the solver's page is open and can be used
 * @property {boolean} usage.inUse - Whether or not the solver is currently in use
 * @property {?Function} usage.current - Promise rejection function to cancel the current promise attached to the current solver's usage
 */

/**
 * @TODO
 *
 * Backlogs in the captcha queue may be caused by the available event not being emitted in some cases, although this should not happen in any case
 *
 * Might want to keep in mind that, const page = (await this.settings.browser.pages())[view.webContents.id - 2]; works, but might change depending
 * on the number of browserviews in the browserwindows, could use injected variable with an id to identify page, and remove the variable once
 * identified
 * 
 * When creating new browserviews,loadurl prior to adding the browserview to a browserwindow, then proceed to fetching the page, otherwise fetching
 * the page from the array of puppeteer's browser.pages() gets messed up
 */
module.exports = class CaptchaSolver {
  /**
   * Constructor to create a captcha solver, must call the initialize function once constructed
   *
   * Flags that must be appended to electron:
   *
   * app.commandLine.appendSwitch("remote-debugging-port", port);
   *
   * For allowing puppeteer to connect to the electron's chromium window's chrome devtools protocol websocket
   *
   * app.commandLine.appendSwitch('disable-site-isolation-trials');
   *
   * This disables running each site in it's own process for web security reasons, disabling the flag allows access to cross origin iframes for automated mouse events
   *
   */
  constructor() {
    /**
     * List of solvers
     * @type {SolverInfo[]}
     */
    this.solvers = []

    /**
     * List of sessions
     * @type {Session[]}
     */
    this.sessions = []

    /**
     * List of windows
     * @type {WindowInfo[]}
     */
    this.windows = []

    /**
     * Settings containing the main window browser object
     */
    this.settings = {
      webSocketDebuggerUrl: null,
      browser: null,
    }

    // List of hosts with ports to proxy
    this.proxiedHosts = ["www.google.com:443", "geo.captcha-delivery.com:443", "api-js.datadome.co:443"]

    // Queue of captchas to be solved
    this.queue = []

    // Emitter for captcha queue
    this.emitter = new EventEmitter()

    // Captcha queue handling
    this.emitter.on('available', async solverId => {
      if (this.queue.length) {
        // Get the first captcha request in the queue
        const { type, url, siteKey, action, resolve, reject } = this.queue[0]
        try {
          // Find a solver that is the same id as the available solver, is available, and is not in use
          if (this.solvers.some(_solver => _solver.id === solverId && _solver.usage.available && !_solver.usage.inUse)) {
            // Remove the captcha request from the front of the queue
            this.queue.shift()

            const solverInfo = this.solvers.find(_solver => _solver.id === solverId && _solver.usage.available && !_solver.usage.inUse)
            solverInfo.usage.inUse = true

            let captchaToken

            // Solve the corresponding captcha type
            switch (type) {
              case 'RECAPTCHA_V2_VISIBLE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV2Visible, { solverId: solverInfo.id, url, siteKey })
                break
              case 'RECAPTCHA_V3_INVISIBLE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV3Invisible, { solverId: solverInfo.id, url, siteKey, action })
                break
              case 'RECAPTCHA_V2_INVISIBLE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV2Invisible, { solverId: solverInfo.id, url, siteKey })
                break
              case 'DATADOME_GEETEST_SLIDE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveDatadomeGeetestSlide, {solverId: solverInfo.id, url})
                break;    
            }

            solverInfo.usage.inUse = false

            if (captchaToken) {
              // If acquiring a captcha token is successful, notify that the solver is available, and resolve the promise with the captchaToken
              this.emitter.emit('available', solverInfo.id)
              return resolve(captchaToken)
            } else this.queue.unshift({ type, url, siteKey, action, resolve, reject })
          } else return reject()
        } catch (err) {
          return reject()
        }
      } else return
    })

    // Difference between view.webContents.id corresponding to the given view's matching puppeteer page from the this.settings.browser.pages() array
    this.viewPageDifference = 2

    // Promise to await
  }

  randomUUIDV4 = () => {
    return `${crypto.randomBytes(4).toString('hex')}-${crypto.randomBytes(2).toString('hex')}-4${crypto.randomBytes(2).toString('hex').slice(1, 4)}-${crypto.randomBytes(2).toString('hex')}-${crypto.randomBytes(6).toString('hex')}`
  }
  randomInt = (min, max) => {
    const randomString = `${crypto.randomBytes(8).toString('hex')}-${Date.now()}`
    random.use(seedrandom(randomString))
    return random.int(min, max)
  }
  randomFloat = (min, max) => {
    const randomString = `${crypto.randomBytes(8).toString('hex')}-${Date.now()}`
    random.use(seedrandom(randomString))
    return random.float(min, max)
  }
  startUrl = file => (process.env.ELECTRON_START_URL && `${process.env.ELECTRON_START_URL}/${file}`) || url.format({ pathname: path.join(app.getAppPath(), `./${file}`), protocol: 'file:', slashes: true })

  /**
   * Creates and initializes the main captcha window
   *
   * @function initialize
   *
   * @param {Object} args - Arguments to initialize main captcha window
   * @param {number} args.port - Open port of the window initialized
   */
  initialize({ port }) {
    return new Promise((resolve, reject) => {
      try {
        // Create main window
        const window = new BrowserWindow({
          width: 375,
          height: 701,
          minWidth: 280,
          minHeight: 701,
          maxWidth: 675,
          // maxWidth: 375,
          maxHeight: 701,
          show: false,
          backgroundColor: '#191E28',
          frame: false,
          autoHideMenuBar: true,
          darkTheme: true,
          transparent: false,
          webPreferences: {
            preload: path.join(app.getAppPath(), './main.api.js'),
            nodeIntegration: false,
            enableRemoteModule: false,
            contextIsolation: true,
          },
        })
        
        if (app.isPackaged) window.removeMenu()

        // Load react
        window.loadURL(this.startUrl('solver.html'))

        // Show window once react is loaded
        window.webContents.on('did-finish-load', () => window.show())

        const id = this.randomUUIDV4()
        // Send message to identify window
        window.webContents.send('message', { id, type: 'main' })

        // Add main window into list of windows
        this.windows.push({
          id,
          type: 'main',
          window,
          height: 500,
          width: 375,
          offsetX: 0,
          offsetY: 71,
        })

        // Get the webSocketDebuggerUrl of the electron BrowserWindow being used as the solver
        axios.get(`http://localhost:${port}/json/version`)
          .then(async res => {
            if (res.status === 200) {
              const resJSON = res.data
              if (resJSON.webSocketDebuggerUrl) {
                this.settings.webSocketDebuggerUrl = resJSON.webSocketDebuggerUrl
                this.settings.browser = await puppeteer.connect({ defaultViewport: null, browserWSEndpoint: resJSON.webSocketDebuggerUrl })
                return resolve()
              } else throw new Error('Websocket debugger url not found')
            } else throw new Error(`HTTP request status not 200 while fetching websocket debugger url, status: ${res.statusCode}`)
          }).catch(err => {
            throw new Error(err)
          })
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Creates a new satellite window for drag-out logic
   *
   * @function createNewSatelliteSolver
   */
  createNewSatelliteSolver() {
    return new Promise((resolve, reject) => {
      try {
        // Create satellite window
        const window = new BrowserWindow({
          width: 375,
          height: 701,
          minWidth: 280,
          minHeight: 701,
          maxWidth: 675,
          // maxWidth: 375,
          maxHeight: 701,
          show: false,
          backgroundColor: '#191E28',
          frame: false,
          autoHideMenuBar: true,
          darkTheme: true,
          transparent: false,
          webPreferences: {
            preload: path.join(app.getAppPath(), './main.api.js'),
            nodeIntegration: false,
            enableRemoteModule: false,
            contextIsolation: true,
          },
        })

        if (app.isPackaged) window.removeMenu()

        // Load react
        window.loadURL(this.startUrl('solver.html'))

        // Show window once react is loaded
        window.webContents.on('did-finish-load', () => window.show())

        const id = this.randomUUIDV4()
        // Send message to identify window
        window.webContents.send('message', { id, type: 'satellite' })

        // Add satellite window into list of windows
        this.windows.push({
          id,
          type: 'satellite',
          window,
          height: 500,
          width: 375,
          offsetX: 0,
          offsetY: 71,
        })

        return resolve(id)
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Deletes a solver window, intended for use with only satellite windows
   *
   * @function deleteSolverWindow
   *
   * @param {Object} args - Arguments to delete a solver window
   * @param {string} args.windowId - Id of the window to be deleted
   */
  deleteSolverWindow({ windowId }, callback) {
    try {
      if (this.solvers.some(solver => solver.window.id === windowId)) throw new Error('Window is in use')
      else {
        if (this.windows.find(window => window.id === windowId)) {
            const windowInfo = this.windows.find(window => window.id === windowId)

            windowInfo.window.once('closed', () => {

                // Increment viewPageDifference, as the page array length decrements on window closed, but the webContents.id stays the same causing a net increase of 1 between webContents.id viewPageDifference
                this.viewPageDifference++

                // Delete the window from the class's windows list
                const windowIndex = this.windows.findIndex(window => window.id === windowId)
                // Unneeded to check if windowIndex exists, as this shouldn't be ran if it doesn't, but put for readability with other functions
                if (windowIndex > -1) {
                    this.windows.splice(windowIndex, 1)

                    return callback ? callback({ success: true }) : { success: true }
                }
            })

            // Destroy the window
            windowInfo.window.destroy()
        } else throw new Error('Window id not found in stored windows')
      }
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Changes the window of a solver
   *
   * @function changeSolverWindow
   *
   * @param {Object} args - Arguments to change the window of a solver
   * @param {string} args.solverId - Id of solver to be changed to a given window
   * @param {string} args.windowId - Id of the window to change a solver to
   */
  changeSolverWindow({ solverId, windowId }, callback) {
    try {
      // Does not need to check if its in use or available, because it's just switching browserviews from one window to another
      if (this.solvers.find(solver => solver.id === solverId) && this.windows.find(window => window.id === windowId)) {
        const solverInfo = this.solvers.find(solver => solver.id === solverId)
        const windowInfo = this.windows.find(window => window.id === windowId)

        // Remove BrowserView from the current window the solver is attached to
        const currentWindowInfo = this.windows.find(window => window.id === solverInfo.window.id)
        currentWindowInfo.window.removeBrowserView(solverInfo.view)

        // Add BrowserView to the new window
        windowInfo.window.addBrowserView(solverInfo.view)

        // Send message to the window to update its state
        windowInfo.window.webContents.send('message', { type: 'update' })

        // Update bounds for the BrowserView to match the new window's
        solverInfo.view.setBounds({ x: windowInfo.offsetX, y: windowInfo.offsetY, width: windowInfo.width, height: windowInfo.height })

        // Change solver's current window info
        solverInfo.window = windowInfo

        return callback ? callback({ success: true }) : { success: true }
      } else throw new Error('Solver or window id not found in stored solvers or windows')
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Creates a local proxy server used to rotate a puppeteer page's proxy via a callback
   *
   * @function createProxyServer
   *
   * @param {Object} args - Arguments to create a proxy server
   * @param {number} args.port - Port to run local proxy server on
   */
  createProxyServer({ port }, callback) {
    try {
      // Variable defining what proxy to use on the request
      let proxy = undefined

      // Setup a new local proxy server which proxies specific host:port addresses
      const server = new ProxyChain.Server({
        port,
        prepareRequestFunction: ({ request }) => {
          return {
            upstreamProxyUrl: this.proxiedHosts.includes(request.url) && proxy,
          }
        },
      })

      // Used to rotate the proxy, a current proxy property is assigned to be used for identifying the currently used proxy
      server.rotate = _proxy => {
        server.current = _proxy
        proxy = _proxy ? `http://${_proxy.username && _proxy.password ? `${_proxy.username}:${_proxy.password}@` : ''}${_proxy.host}:${_proxy.port}` : undefined
      }

      server.listen()

      return server
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Creates a new default session by fetching google cookies to use
   *
   * @function createNewDefaultSession
   */
  createNewDefaultSession() {
    return new Promise(async (resolve, reject) => {
      try {
        // Secondary headless solver is created to fetch google cookies
        const browser = await puppeteer.launch({  executablePath: getChromiumExecPath(), headless: true, args: ['--ignore-certificate-errors', '--disable-features=IsolateOrigins,site-per-process'] })

        // Must do this to register puppeteer-extra-plugin-stealth properties on initial solver launch page
        const [page] = await browser.pages()
        browser.emitter.emit('targetcreated', page.target())
        await page.reload()

        // Go to the default google url to initialize a session
        await page.goto(DEFAULT_GOOGLE_URL)

        // Save the newly created session's cookie, localStorage and sessionStorage data
        const data = await page._client.send('Network.getAllCookies')
        data.localStorage = await page.evaluate(() => ({ ...window.localStorage }))
        data.sessionStorage = await page.evaluate(() => ({ ...window.sessionStorage }))

        await browser.close()

        return resolve(data)
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Creates a new google account signed in session, expects client to pass an id of a newly created empty default solver
   * 
   * This method updates the session of the solver to a newly generated temporary default session, if the method throws an
   * error, by refreshing or closing the solver, the solver should be updated back to its prior session, before
   * continuing with any further action, as the temporary session will persist on the solver until the method resolves
   *
   * @function createNewGoogleAccountSession
   *
   * @param {Object} args - Arguments to create a new google account signed in sesssion
   * @param {string} args.solverId - Id of the desired solver to be used to get google account cookies
   * @param {string} args.name - Name to give newly created session
   */
  createNewGoogleAccountSession({ solverId, name }) {
    return new Promise(async (resolve, reject) => {
      try {
        if (this.solvers.some(_solver => _solver.id === solverId && _solver.usage.available && !_solver.usage.inUse)) {
          const solverInfo = this.solvers.find(_solver => _solver.id === solverId)
          solverInfo.usage.inUse = true
          solverInfo.usage.current = reject
          const page = solverInfo.page

          const _session = {
            name: undefined,
            id: this.randomUUIDV4(),
            ...(await this.createNewDefaultSession()),
          }
          let previousSessionId = solverInfo.session.id
          this.sessions.push(_session)

          await this.updateSession({solverId, sessionId: _session.id, bypassInuse: true})

          // Intercept the response once the client has logged into gmail and is being redirected
          this.interceptResponse(
            {
              page,
              interception: { url: /(https:\/\/myaccount\.google\.com\/|https:\/\/myaccount\.google\.com\/\?pli=1)(?!(\?|[a-zA-z]|[0-9]))/ },
            },
            async () => {
                try {
                    const id = this.randomUUIDV4()
                    // Fetch google account cookies
                    const cookies = (await page._client.send('Network.getAllCookies')).cookies
      
                    // Setup an interception of the default google url to be replaced with the default captcha window content
                    await this.interceptRequest({
                      page,
                      interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
                    })
      
                    // Reset solver view once google account cookies are fetched
                    await page.goto(DEFAULT_GOOGLE_URL)
                    // Fetch google page localStorage and sessionStorage from default google url
                    const localStorage = await page.evaluate(() => ({ ...window.localStorage }))
                    const sessionStorage = await page.evaluate(() => ({ ...window.sessionStorage }))
      
                    // Fetch cookies and push to a new session
                    this.sessions.push({
                      name,
                      id,
                      cookies,
                      localStorage,
                      sessionStorage,
                    })
      
                    // Revert solver back to the previous session, and delete the temporary google account session
                    await this.updateSession({solverId, sessionId: previousSessionId, bypassInuse: true})
                    this.deleteSession({sessionId: previousSessionId})
      
                    solverInfo.usage.inUse = false
                    this.emitter.emit('available', solverInfo.id)
      
                    return resolve(id)      
                } catch (err) {
                    return reject(err)
                }
            }
          )

          await page.goto(GOOGLE_ACCOUNT_LOGIN_URL)
        } else throw new Error('Solver in use')
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Creates a new solver window
   *
   * @function createNewSolverWindow
   *
   * @param {Object} args - Arguments to create a new solver window
   * @param {string} args.proxy - Proxy to initialize solver with
   * @param {boolean} args.autoClickCaptcha - Whether or not captchas should be auto clicked
   */
  createNewSolverWindow({ proxy, autoClickCaptcha }) {
    return new Promise(async (resolve, reject) => {
      try {
        // Initialize proxy server used to rotate proxies
        const proxyServer = this.createProxyServer({ port: await getPort() })
        // Create an electron session from a random partition string
        const electronSession = session.fromPartition(this.randomUUIDV4(), { cache: false })
        // Set the session's proxy to the newly created proxy server
        await electronSession.setProxy({ proxyRules: `http://localhost:${proxyServer.port}` })
        // Set the session's proxy to the desired user agent
        electronSession.setUserAgent(DEFAULT_CAPTCHA_SOLVER_USER_AGENT)
        // Initialize an electron BrowserView with the newly created session
        const view = new BrowserView({
          webPreferences: {
            // backgroundThrottling: false,
            session: electronSession,
            contextIsolation: true,
            nodeIntegration: false,
            enableRemoteModule: false,
          },
        })

        // Attach browserview to the browserwindow
        await view.webContents.loadURL(`data:text/html,${DEFAULT_CAPTCHA_WINDOW_CONTENT}`)
        const windowInfo = this.windows.find(window => window.type === 'main')
        windowInfo.window.addBrowserView(view)
        view.setBounds({ x: windowInfo.offsetX, y: windowInfo.offsetY, width: windowInfo.width, height: windowInfo.height })

        // Get the puppeteer page object of the added browserview
        const page = (await this.settings.browser.pages())[view.webContents.id - this.viewPageDifference]

        // Push the newly created session into the list of sessions
        const _session = {
          name: undefined,
          id: this.randomUUIDV4(),
          ...(await this.createNewDefaultSession()),
        }
        this.sessions.push(_session)

        // Push the newly created solver into the list of solvers
        const id = this.randomUUIDV4()
        this.solvers.push({ id, page, view, window: windowInfo, session: _session, originalSessionId: _session.id, proxy: proxyServer, autoClickCaptcha, usage: { available: true, inUse: false, current: null } })

        // Register page on close logic
        page.on('close', () => {
          const solverInfo = this.solvers.find(_solver => _solver.id === id)
          solverInfo.usage.available = false
        })

        // Rotate the proxy, and initialize the solver with the session's cookies
        proxyServer.rotate(proxy)

        await page.setCookie(..._session.cookies)
        
        // Bypass content-security-policy of any pages
        await page.setBypassCSP(true)

        // Setup an interception of the default google url to be replaced with the default captcha window content
        await this.interceptRequest({
          page,
          interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
        })

        await page.goto(DEFAULT_GOOGLE_URL)

        // Initialize the solver with the session's local and session storage
        await page.evaluate(_session => {
          Object.keys(_session.localStorage).forEach(key => window.localStorage.setItem(key, _session.localStorage[key]))
          Object.keys(_session.sessionStorage).forEach(key => window.sessionStorage.setItem(key, _session.sessionStorage[key]))
        }, _session)

        // Emit available event to prompt captchas from the queue onto the new solver
        this.emitter.emit('available', id)

        return resolve(id)
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Exports all solver windows into a reloadable JSON object
   *
   * @function exportSolvers
   */
  exportSolvers(callback) {
    try {
      const exportArray = this.solvers.map(solverInfo => ({ id: solverInfo.id, windowId: solverInfo.window.id, sessionId: solverInfo.session.id, originalSessionId: solverInfo.originalSessionId, proxy: solverInfo.proxy.current, autoClickCaptcha: solverInfo.autoClickCaptcha }))

      return callback ? callback(exportArray) : exportArray
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Exports all sessions saved
   *
   * @function exportSessions
   */
  exportSessions(callback) {
    try {
      return callback ? callback(this.sessions) : this.sessions
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Imports new sessions from an array of exported sessions
   *
   * @function importSessions
   *
   * @param {Object} args - Arguments to import sessions
   * @param {Array.<Session>} args.sessions - Sessions to be imported
   */
  importSessions({ sessions }, callback) {
    try {
      // Filter locally duplicate session names and ids
      let _sessions = sessions.filter((session, i) => sessions.findIndex(_session => _session.id === session.id || (session.name !== null && _session.name === session.name)) === i)
      // Filter duplicate session names and ids against currently used sessions
      _sessions = sessions.filter(session => !this.sessions.some(_session => _session.id === session.id || (session.name !== null && _session.name === session.name)))

      this.sessions.push(..._sessions)

      return callback ? callback({ success: true }) : { success: true }
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Returns a promise for containing logic for importing a solver
   *
   * @function importSolverLogic
   *
   * @param {Solver} solver - Solver to be imported
   *
   */
  importSolverLogic({ solver }) {
    return new Promise(async (resolve, reject) => {
      try {
        const _session = this.sessions.find(_session => _session.id === solver.sessionId)

        if (_session) {
          // Initialize proxy server used to rotate proxies
          const proxyServer = this.createProxyServer({ port: await getPort() })
          // Create an electron session from a random partition string
          const electronSession = session.fromPartition(this.randomUUIDV4(), { cache: false })
          // Set the session's proxy to the newly created proxy server
          await electronSession.setProxy({ proxyRules: `http://localhost:${proxyServer.port}` })
          // Set the session's proxy to the desired user agent
          electronSession.setUserAgent(DEFAULT_CAPTCHA_SOLVER_USER_AGENT)
          // Initialize an electron BrowserView with the newly created session
          const view = new BrowserView({
            webPreferences: {
              // backgroundThrottling: false,
              session: electronSession,
              contextIsolation: true,
              nodeIntegration: false,
              enableRemoteModule: false  
            },
          })

          // Attach browserview to the browserwindow
          await view.webContents.loadURL(`data:text/html,${DEFAULT_CAPTCHA_WINDOW_CONTENT}`)
          const windowInfo = this.windows.find(window => window.type === 'main')
          windowInfo.window.addBrowserView(view)
          view.setBounds({ x: windowInfo.offsetX, y: windowInfo.offsetY, width: windowInfo.width, height: windowInfo.height })

          // Get the puppeteer page object of the added browserview
          const page = (await this.settings.browser.pages())[view.webContents.id - this.viewPageDifference]

          // Push the newly created solver into the list of solvers
          const id = this.randomUUIDV4()
          this.solvers.push({ id, page, view, window: windowInfo, session: _session, originalSessionId: solver.originalSessionId, proxy: proxyServer, autoClickCaptcha: solver.autoClickCaptcha, usage: { available: true, inUse: false, current: null } })

          // Register page on close logic
          page.on('close', () => {
            const solverInfo = this.solvers.find(_solver => _solver.id === id)
            solverInfo.usage.available = false
          })

          // Rotate the proxy, and initialize the solver with the session's cookies
          proxyServer.rotate(solver.proxy)
          await page.setCookie(..._session.cookies)

          // Bypass content-security-policy of any pages
          await page.setBypassCSP(true)

          // Setup an interception of the default google url to be replaced with the default captcha window content
          await this.interceptRequest({
            page,
            interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
          })

          await page.goto(DEFAULT_GOOGLE_URL)

          // Initialize the solver with the session's local and session storage
          await page.evaluate(_session => {
            Object.keys(_session.localStorage).forEach(key => window.localStorage.setItem(key, _session.localStorage[key]))
            Object.keys(_session.sessionStorage).forEach(key => window.sessionStorage.setItem(key, _session.sessionStorage[key]))
          }, _session)

          return resolve()
        } else throw new Error('Session id not found in stored sessions')
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Imports new solver windows from an array of exported solver's
   *
   * @function importSolvers
   *
   * @param {Object} args - Arguments to import new solver windows
   * @param {Array.<Solver>} args.solvers - List of solver's with data to initialize the solver window with
   */
  importSolvers({ solvers }) {
    return new Promise(async (resolve, reject) => {
      try {
        const createSolverPromises = []
        solvers.forEach(solver => createSolverPromises.push(this.importSolverLogic.bind(this)({ solver })))
        Promise.all(createSolverPromises).then(resolve)
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Updates a given solver's session
   *
   * @function updateSession
   *
   * @param {Object} args - Arguments to update a given solver's session
   * @param {string} args.solverId - Id of the desired solver to update session settings
   * @param {string} args.sessionId - Id of the session to be updated with
   * @param {boolean} args.bypassInuse - Bypasses the check for the inUse property on the solver also bypasses the current (cancel) property being set to this reject, used for internal methods
   *
   * @todo Going to the DEFAULT_GOOGLE_URL and intercepting may be trivial, as the solver should be on the DEFAULT_GOOGLE_URL variable if it is not in use
   */
  updateSession({ solverId, sessionId, bypassInuse}) {
    return new Promise(async (resolve, reject) => {
      try {
        if (this.solvers.some(_solver => _solver.id === solverId && _solver.usage.available && (bypassInuse || !_solver.usage.inUse)) && this.sessions.find(_session => _session.id === sessionId)) {
          const solverInfo = this.solvers.find(_solver => _solver.id === solverId && _solver.usage.available && (bypassInuse || !_solver.usage.inUse))
          !bypassInuse && (solverInfo.usage.inUse = true)
          !bypassInuse && (solverInfo.usage.current = reject)
          const page = solverInfo.page

          const _session = this.sessions.find(__session => __session.id === sessionId)

          // Clear the solver's old cookies
          const oldCookies = (await page._client.send('Network.getAllCookies')).cookies

          for (const cookie of oldCookies) {
            await page._client.send('Network.deleteCookies', cookie)
          }

          // Update the solver with the new session's cookies
          await page.setCookie(..._session.cookies)

          // Setup an interception of the default google url to be replaced with the default captcha window content
          await this.interceptRequest({
            page,
            interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
          })

          await page.goto(DEFAULT_GOOGLE_URL)

          // Remove the old session's local and session storage, then update the solver with the new session's local and session storage
          await page.evaluate(_session => {
            Object.keys(window.localStorage).forEach(key => window.localStorage.removeItem(key))
            Object.keys(window.sessionStorage).forEach(key => window.sessionStorage.removeItem(key))

            Object.keys(_session.localStorage).forEach(key => window.localStorage.setItem(key, _session.localStorage[key]))
            Object.keys(_session.sessionStorage).forEach(key => window.sessionStorage.setItem(key, _session.sessionStorage[key]))
          }, _session)

          // Update the solver's session info
          solverInfo.session = _session
          !bypassInuse && (solverInfo.usage.inUse = false)
          this.emitter.emit('available', solverInfo.id)
          return resolve()
        } else throw new Error('Solver, and session id not found or not available currently')
      } catch (err) {
        return reject()
      }
    })
  }

  /**
   * Deletes and closes a given solver from the class
   *
   * @param {Object} args
   * @param {string} args.solverId - Id of the desired solver to be deleted
   */
  deleteSolver({ solverId }, callback) {
    try {
      if (this.solvers.find(solver => solver.id === solverId)) {
        const solverInfo = this.solvers.find(_solver => _solver.id === solverId)
        // Cancel current usage by calling the promise rejection function if present, as false incase it is a solve that is occuring, to be pushed to front of queue
        if (solverInfo && solverInfo.usage.inUse && solverInfo.usage.current) solverInfo.usage.current(false)

        // Set available variable to false, and inUse to true incase the solver gets another use in between this fraction of a time period
        solverInfo.usage.available = false
        solverInfo.usage.inUse = true

        // Remove the solver's attached browserview from the browserwindow
        const windowInfo = this.windows.find(window => window.type === 'main') // Solvers can only be deleted from the main window, not satellite windows
        windowInfo.window.removeBrowserView(solverInfo.view)

        // Delete the solver from the class's solvers list
        const solverIndex = this.solvers.findIndex(_solver => _solver.id === solverId)
        // Unneeded to check if solverIndex exists, as this shouldn't be ran if it doesn't, but put for readability with other functions
        if (solverIndex > -1) {
          this.solvers.splice(solverIndex, 1)

          return callback ? callback({ success: true }) : true
        }
      } else throw new Error('Solver id not found in stored solvers')
    } catch (err) {
      return callback ? callback({ sucess: false, err }) : { success: false, err }
    }
  }

  /**
   * Deletes and closes a given session from the class
   *
   * @param {Object} args
   * @param {string} args.sessionId - Id of the desired session to be deleted
   */
  deleteSession({ sessionId }, callback) {
    try {
      // Check if session is in use, return unsuccessful if so
      if (this.solvers.some(_solver => _solver.session.id === sessionId)) throw new Error('Session is in use')
      else {
        // Delete the session from the class's sessions list
        const sessionIndex = this.sessions.findIndex(_session => _session.id === sessionId)
        if (sessionIndex > -1) {
          this.sessions.splice(sessionIndex, 1)

          return callback ? callback({ success: true }) : true
        } else throw new Error('Session id not found in stored sessions')
      }
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Refreshes a solver, and if solving a captcha stops, pushing it to the front of the captcha queue
   *
   * @param {Object} args
   * @param {string} args.solverId - Id of the desired solver to be deleted
   */
  refreshSolver({ solverId }) {
    return new Promise(async (resolve, reject) => {
      try {
        const solverInfo = this.solvers.find(_solver => _solver.id === solverId)

        solverInfo.usage.inUse = true
        const page = solverInfo.page

        // Setup an interception of the default google url to be replaced with the default captcha window content
        await this.interceptRequest({
          page,
          interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
        }, () => {
            // Set inuse to false prior to rejecting the function
            solverInfo.usage.inUse = false

            // Cancel current usage by calling the promise rejection function if present, as false incase it is a solve that is occuring, to be pushed to front of queue
            if (solverInfo.usage.current) solverInfo.usage.current(false)

            this.emitter.emit('available', solverInfo.id)

            return resolve()
        })

        // Reset solver view by going to the intercepted url
        await page.goto(DEFAULT_GOOGLE_URL)
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Modifies whether a given solver should auto click captchas
   *
   * @function updateAutoClickCaptcha
   *
   * @param {Object} args - Arguments to modify whether a solver should auto click captchas
   * @param {string} args.solverId - Id of the desired solver to update auto click captcha settings
   * @param {boolean} args.autoClickCaptcha - Whether or not captchas should be auto clicked
   */
  updateAutoClickCaptcha({ solverId, autoClickCaptcha }, callback) {
    try {
      const solverInfo = this.solvers.find(_solver => _solver.id === solverId)

      solverInfo.autoClickCaptcha = autoClickCaptcha

      return callback ? callback({ success: true }) : true
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Rotates a given solver's proxy via latter's id
   *
   * @function rotateProxy
   *
   * @param {Object} args - Arguments to rotate a given solver's proxy via latter's id
   * @param {string} args.solverId - Id of the desired solver to rotate the proxy to
   * @param {{host: string, port: number, username: string | undefined, password: string | undefined}} args.proxy - Parsed proxy to be rotated to
   */
  rotateProxy({ solverId, proxy }, callback) {
    try {
      const solverInfo = this.solvers.find(_solver => _solver.id === solverId)

      solverInfo.proxy.rotate(proxy)

      return callback ? callback({ success: true }) : true
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Intercept a request given a URL
   *
   * @function interceptRequest
   *
   * @param {Object} args - Arguments to intercept a request
   * @param {Object} args.page - Puppeteer page
   * @param {Interception} args.interception - Url to intercept, and content along with it's content type to replace it with
   * @param {?Function} args.callback - If no interception content is provided, provide a callback which is passed the request itself, the intercepted request is aborted
   */
  interceptRequest({ page, interception }, callback) {
    return new Promise(async (resolve, reject) => {
      try {
        const client = await page.target().createCDPSession()

        await client.send('Fetch.enable', {
          patterns: [{ urlPattern: '*', requestStage: 'Request' }],
        })

        client.on('Fetch.requestPaused', async interceptedRequest => {
            try {
                if (interception.regex === false ? interception.url === interceptedRequest.request.url : interception.url.test(interceptedRequest.request.url)) {
                    if (interception.content) {
                      await client.send('Fetch.fulfillRequest', {
                          requestId: interceptedRequest.requestId,
                          responseCode: 200,
                          responseHeaders: [{ name: 'content-type', value: interception.contentType }],
                          body: Buffer.from(interception.content).toString('base64'),
                        })
                    } else if (interception.stop === true) await client.send('Fetch.failRequest', { requestId: interceptedRequest.requestId, errorReason: 'Aborted' })
                    else await client.send('Fetch.continueRequest', { requestId: interceptedRequest.requestId })
      
                    if (callback) callback(interceptedRequest.request)
      
                    await client.detach()
                } else {
                  await client.send('Fetch.continueRequest', { requestId: interceptedRequest.requestId })
                }      
            } catch (err) {
                console.error('Error in function: interceptRequest, callback for Fetch.requestPaused: ', err)
                return
            }
        })

        return resolve()
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Intercept a response given a URL
   * 
   * The response.body is encoded in base64, to handle binary response data ensure
   * the response.body parameter is decoded from base64 when handling text/plain
   * content-type data
   *
   * @function interceptResponse
   *
   * @param {Object} args - Arguments to intercept a response
   * @param {Object} args.page - Puppeteer page
   * @param {Interception} args.interception - Url to intercept
   */
  async interceptResponse({ page, interception }, callback) {
    try {
      const client = await page.target().createCDPSession()

      await client.send('Fetch.enable', {
        patterns: [{ requestStage: 'Response' }],
      })

      client.on('Fetch.requestPaused', async interceptedResponse => {
          try {
            if (interception.regex === false ? interception.url === interceptedResponse.request.url : interception.url.test(interceptedResponse.request.url)) {
                const responseBody = await client.send('Fetch.getResponseBody', { requestId: interceptedResponse.requestId })
      
                await client.send('Fetch.continueRequest', { requestId: interceptedResponse.requestId })
      
                const response = {
                  statusCode: interceptedResponse.responseStatusCode,
                  headers: interceptedResponse.responseHeaders.reduce((obj, header) => ((obj[header.name] = header.value), obj), {}),
                  body: responseBody.body,
                }
      
                await client.detach()
      
                if (callback) callback(response)
              } else {
                await client.send('Fetch.continueRequest', { requestId: interceptedResponse.requestId })
              }      
          } catch (err) {
              console.error('Error in function: interceptResponse, callback for Fetch.requestPaused: ', err)
              return
          }
      })
    } catch (err) {
      return callback ? callback({ success: false, err }) : { success: false, err }
    }
  }

  /**
   * Returns HTML content to solve a visible recaptcha v2
   *
   * @function getRecaptchaV2VisibleContent
   *
   * @param {string} siteKey - Site key of captcha to implement into HTML
   */
  getRecaptchaV2VisibleContent(siteKey) {
    return `
            <!DOCTYPE html>
            <html style="background-color: #191E28;">
                <head>
                    <title>Captcha Solver</title>
                    <script src="https://www.google.com/recaptcha/api.js"></script>
                </head>
                <body>
                    <div class="g-recaptcha" data-sitekey="${siteKey}"></div>
                </body>
            </html>
        `
  }

  getRecaptchaV2InvisibleContent(siteKey) {
    return `
        <!DOCTYPE html>
        <html style="background-color: #191E28;">
            <head>
                <title>Captcha Solver</title>
                <script src="https://www.google.com/recaptcha/api.js"></script>
            </head>
            <body>
                <div class="g-recaptcha" data-sitekey=${siteKey} data-size="invisible"></div>
                <script>
                    grecaptcha.ready(() => {
                        grecaptcha.execute();
                    })
                </script>
            </body>
        </html>
    `
}

  /**
   * Returns HTML content to solve a invisible recaptcha v3
   *
   * @function getRecaptchaV3InvisibleContent
   *
   * @param {string} siteKey - Site key of captcha to implement into HTML
   * @param {string} action - Action of recaptcha v3 to implement into HTML
   *
   */
  getRecaptchaV3InvisibleContent(siteKey, action) {
    return `
            <!DOCTYPE html>
            <html style="background-color: #191E28;">
                <head>
                    <title>Captcha Solver</title>
                    <script src="https://www.google.com/recaptcha/api.js?render=${siteKey}"></script>
                </head>
                <body>
                    <script>
                        grecaptcha.ready(() => {
                            grecaptcha.execute("${siteKey}", {action: "${action}"});
                        })
                    </script>
                </body>
            </html>
        `
  }

  /**
   * Solves for a invisible v3 recaptcha
   *
   * @function solveRecaptchaV3Invisible
   *
   * @param {Object} args - Arguments to request a solve for an invisible v3 recaptcha
   * @param {string} args.solverId - Id of the desired solver to request a solve for an invisible v3 recaptcha
   * @param {string} args.url - Url of the page with an invisible v3 recpatcha
   * @param {string} args.siteKey - Site key of the page with an invisible v3 recaptcha
   * @param {string} args.action - Action of the invisible v3 recaptcha
   *
   * @todo Look into mimicking human-like mouse movements on v3 invisible recaptcha before requesting it for higher scores
   */
  solveRecaptchaV3Invisible({ solverId, url, siteKey, action }) {
    return new Promise(async (resolve, reject) => {
      try {
        // Don't need to update <Solver>.usage.inUse variable, as it's managed by the intermediate captcha queue handling methods
        const solverInfo = this.solvers.find(_solver => _solver.id === solverId)
        solverInfo.usage.current = reject
        const page = solverInfo.page
        page.on('close', () => {
          // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
          return reject(false)
        })

        // Setup an interception for the captcha token
        this.interceptResponse(
            {
              page,
              interception: { url: /https:\/\/www\.google\.com\/recaptcha\/api2\/reload/ },
            },
            async res => {
                try {
                    // Extract captcha token from response body
                    const captchaToken = /("rresp",)(")(.*?)(",)/gm.exec(Buffer.from(res.body, 'base64').toString())[3]
        
                    // Reset to default captcha window content once solved
                    await this.interceptRequest({
                        page,
                        interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
                    })
        
                    await page.goto(DEFAULT_GOOGLE_URL)            
        
                    // Verify captcha token exists
                    if (captchaToken) {
                        // If captcha token exists, resolve 
                        return resolve(captchaToken)
                    } else {
                        // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
                        return reject(true)
                    }
                } catch (err) {
                    return reject(true)
                }
            }
          )  

        // Intercept the invisible recaptcha v3 URL, replace it with the invisible recaptcha v3 content to simulate being on the same site
        await this.interceptRequest({
          page,
          interception: { url: new RegExp(url.replace(/\?/g, '\\?')), content: this.getRecaptchaV3InvisibleContent(siteKey, action), contentType: 'text/html' },
        })

        await page.goto(url)

      } catch (err) {
        // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
        return reject(false)
      }
    })
  }

  /**
   * Solves for a visible v2 recaptcha
   *
   * @function solveRecaptchaV2Visible
   *
   * @param {Object} args - Arguments to request a solve for a visible v2 recaptcha
   * @param {string} args.solverId - Id of the desired solver to request a solve for an invisible v3 recaptcha
   * @param {string} args.url - Url of the page with a visible v2 recpatcha
   * @param {string} args.siteKey - Site key of the page with a visible v2 recaptcha
   */
  solveRecaptchaV2Visible({ solverId, url, siteKey }) {
    return new Promise(async (resolve, reject) => {
      try {
        // Don't need to update <Solver>.usage.inUse variable, as it's managed by the intermediate captcha queue handling methods
        const solverInfo = this.solvers.find(_solver => _solver.id === solverId)
        solverInfo.usage.current = reject
        const page = solverInfo.page
        page.on('close', () => {
          // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
          return reject(false)
        })

        // Create a cursor to mimic human-like mouse movements to positions and clicks on the page
        const cursor = createCursor(page, { x: this.randomInt(0, 1920), y: this.randomInt(0, 1080) })

        // Intercept the visible recaptcha v2 URL, replace it with the visible recaptcha v2 content to simulate being on the same site
        await this.interceptRequest({
          page,
          interception: { url: new RegExp(url.replace(/\?/g, '\\?')), content: this.getRecaptchaV2VisibleContent(siteKey), contentType: 'text/html' },
        })

        // TODO
        // Move solver to front before this?
        // const { window } = solverInfo.window
        // try {
        //     window.setTopBrowserView(solverInfo.view)
        // } catch (err) {
        //     console.error('Unable to set top browser view', solverId, err.message)
        // }
        // window.webContents.send('message', { id: solverInfo.id, type: 'focus' })

        this.interceptResponse(
          {
            page,
            interception: { url: /https:\/\/www\.google\.com\/recaptcha\/api2\/userverify/ },
          }, async res => {
              try {
                // Extract captcha token from response body
                const captchaToken = /("uvresp",)(")(.*?)(",)/gm.exec(Buffer.from(res.body, 'base64').toString())[3]

                // Reset to default captcha window content once solved
                await this.interceptRequest({
                    page,
                    interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
                })

                await page.goto(DEFAULT_GOOGLE_URL)

                // Verify captcha token from length of string
                if (captchaToken && captchaToken.length < 1000) {
                    // If captcha token exists, resolve the captcha token
                    return resolve(captchaToken)
                } else {
                    // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
                    return reject(true)
                }
              } catch (err) {
                  return reject(true)
              }
          }
        )

        const autoClickCaptcha = async _ => {
            try {
                // Auto click the visible recaptcha v2 by accessing the iframe, wait for the recaptcha button and the iframe to be present on screen
                await cursor.click('#recaptcha-anchor', { iframe: 'iframe[src*="api2/anchor"]', waitForIframe: true, waitForSelector: true })
            } catch (err) {
                return reject(true)
            }
        }

        // If auto click captcha is enabled, auto click the captcha
        solverInfo.autoClickCaptcha && autoClickCaptcha()

        await page.goto(url)
      } catch (err) {
        // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
        return reject(false)
      }
    })
  }

    /**
   * Solves for an invisible v2 recaptcha
   *
   * @function solveRecaptchaV2Invisible
   *
   * @param {Object} args - Arguments to request a solve for an invisible v2 recaptcha
   * @param {string} args.solverId - Id of the desired solver to request a solve for an invisible v2 recaptcha
   * @param {string} args.url - Url of the page with an invisible v2 recpatcha
   * @param {string} args.siteKey - Site key of the page with an invisible v2 recaptcha
   *
   * @todo Look into mimicking human-like mouse movements on v2 invisible recaptcha before requesting it for higher scores
   */
  solveRecaptchaV2Invisible({ solverId, url, siteKey }) {
    return new Promise(async (resolve, reject) => {
      try {
        // Don't need to update <Solver>.usage.inUse variable, as it's managed by the intermediate captcha queue handling methods
        const solverInfo = this.solvers.find(_solver => _solver.id === solverId)
        solverInfo.usage.current = reject
        const page = solverInfo.page
        page.on('close', () => {
          // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
          return reject(false)
        })

        // Intercept the invisible recaptcha v3 URL, replace it with the invisible recaptcha v3 content to simulate being on the same site
        await this.interceptRequest({
          page,
          interception: { url: new RegExp(url.replace(/\?/g, '\\?')), content: this.getRecaptchaV2InvisibleContent(siteKey), contentType: 'text/html' },
        })

        this.interceptResponse(
          {
            page,
            interception: { url: /(https:\/\/www\.google\.com\/recaptcha\/api2\/userverify)/ },
          }, async res => {
              try {
                // Extract captcha token from response body
                const captchaToken = /("uvresp",)(")(.*?)(",)/gm.exec(Buffer.from(res.body, 'base64').toString())[3]

                // Reset to default captcha window content once solved
                await this.interceptRequest({
                    page,
                    interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
                })

                await page.goto(DEFAULT_GOOGLE_URL)

                // Verify captcha token exists
                if (captchaToken) {
                    // If captcha token exists, resolve the captcha token
                    return resolve(captchaToken)
                } else {
                    // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
                    return reject(true)
                }
              } catch (err) {
                  return reject(true)
              }
          }
        )

        await page.goto(url)
      } catch (err) {
        // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
        return reject(false)
      }
    })
  }

  /**
   * 
   * @param {Object} args - Arguments to solve a datadome geetest slide captcha
   * @param {string} args.solverId - Id of the desired solver to solve the geetest slide captcha
   * @param {string} args.url - Url of the captcha prompt
   */
  solveDatadomeGeetestSlide({solverId, url}) {
      return new Promise(async (resolve, reject) => {
        try {
            // If opencv has not been initialized, await the promise returned from the require('opencv.js') statement
            if (!openCvRuntimeInitialized) await cv()

            // Don't need to update <Solver>.usage.inUse variable, as it's managed by the intermediate captcha queue handling methods
            const solverInfo = this.solvers.find(({id}) => id === solverId)
                  solverInfo.usage.current = reject

            const page = solverInfo.page,
                  cursor = createCursor(page, {x: this.randomInt(0, 1920), y: this.randomInt(0, 1080)})

            page.on('close', () => {
                // True or false decides whether to retry the solve function until it is solved, or push to beginning of queue
                reject(false)
            })

            this.interceptResponse({
                page,
                interception: {regex: false, url}
            }, async (res) => {
                try {
                    if (res.statusCode === 403) {
                        // Reset to default captcha window content upon forbidden
                        await this.interceptRequest({
                            page,
                            interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
                        })
    
                        await page.goto(DEFAULT_GOOGLE_URL)
    
                        // If navigation status code is forbidden switch to another solver
                        return reject(false)
                    }    
                } catch (err) {
                    return reject(true)
                }
            })

            await page.goto(url, {waitUntil: 'networkidle2'})

            // Click the start button
            await cursor.click('[aria-label="Click to verify"]', { waitForSelector: true })

            let captcha, _, original

            const solveSlide = async () => {
                try {
                    // Setup an interception on the final geetest captcha request to verify it was successful, otherwise retry
                    await this.interceptResponse({
                        page,
                        interception: {url: /ajax\.php/}
                    }, async (res) => {
                        try {
                            if (res.statusCode === 200) {
                                const resJSON = JSON.parse(/^.*?(\((\{.*?})\))/.exec(Buffer.from(res.body, 'base64').toString())[2]) // Parse the JSON from the response callback
                                if (!resJSON.success && resJSON.message === 'fail') {
                                    // Setup an interception to solve the slide captcha once a new captcha has been received
                                    await this.interceptResponse({
                                        page,
                                        interception: {url: /refresh\.php/}
                                    }, async () => {
                                        try {
                                            // Wait for the captcha and original image to be updated to the newly refreshed slide captcha images
                                            await page.waitForFunction((captcha, original) => {
                                                const [_captcha, _, _original] = Array.from(document.querySelectorAll('.geetest_canvas_img canvas'))
                                                return _captcha !== captcha && _original !== original
                                            }, {polling: 'raf'}, captcha, original)
                                            
                                            solveSlide()
                                        } catch (err) {
                                            return reject(true)
                                        }
                                    })
        
                                    // Wait for the slider to reset
                                    await page.waitForSelector('.geetest_slider_button[style="opacity: 1; transform: translate(0px, 0px);"]', {polling: 'raf'})
        
                                    // If the slide was invalid, refresh to get a new slide captcha and try again
                                    await page.waitForSelector('.geetest_refresh_icon', {visible: true})
                                    await cursor.click('.geetest_refresh_icon', { waitForSelector: true })
                                }
                                else if (!resJSON.success) {
                                    // Click the network retry button
                                    await page.waitForSelector('.geetest_reset_tip_content', {visible: true})
                                    await cursor.click('.geetest_reset_tip_content', { waitForSelector: true })
                                    solveSlide()
                                }
                            } else return reject(true) // Status code should always be 200, otherwise retry on the same solver    
                        } catch (err) {
                            return reject(true)
                        }
                    })


                    // Wait for the slider images to be visible
                    await page.waitForSelector('.geetest_canvas_img canvas', {visible: true})
                    try {
                        // Wait for the canvas data url length to be greater than 1572, if it takes more than 15 seconds, retry on the same solver
                        await page.waitForFunction(`Array.from(document.querySelectorAll('.geetest_canvas_img canvas')).every(canvas => canvas.toDataURL().replace('data:image/png;base64', '').length > 1600)`, {polling: 'raf', timeout: 15000})
                    } catch (err) {
                        return reject(true)
                    }

                    // Get the slider images
                    [captcha, _, original] = await page.$$eval('.geetest_canvas_img canvas', canvases => {
                        return canvases.map(canvas => canvas.toDataURL().replace('data:image/png;base64', ''))
                    })

                    captcha = await Jimp.read(Buffer.from(captcha, 'base64'))
                    original = await Jimp.read(Buffer.from(original, 'base64'))

                    // Pixelmatch to find the difference between the original, and the captcha image
                    const _diffImage = new Jimp(original.bitmap.width, original.bitmap.height)
                    pixelMatch(
                        original.bitmap.data,
                        captcha.bitmap.data,
                        _diffImage.bitmap.data,
                        original.bitmap.width,
                        original.bitmap.height,
                        {
                            includeAA: true,
                            threshold: 0.14
                        }
                    )

                    // Enhance difference image via opencv
                    const src = cv.matFromImageData(_diffImage.bitmap)
                    const dst = new cv.Mat()
                    const kernel = cv.Mat.ones(2, 5, cv.CV_8UC1)
                    const anchor = new cv.Point(-1, -1)
                    cv.threshold(src, dst, 127, 255, cv.THRESH_BINARY)
                    cv.erode(dst, dst, kernel, anchor, 1)
                    cv.dilate(dst, dst, kernel, anchor, 1)        

                    // Create enhanced image
                    const diffImage = new Jimp({
                        width: dst.cols,
                        height: dst.rows,
                        data: Buffer.from(dst.data)
                    })

                    const getPuzzlePiecesSlotCenterPosition = (diffImage) => {
                        const src = cv.matFromImageData(diffImage.bitmap)
                        const dst = new cv.Mat()

                        cv.cvtColor(src, src, cv.COLOR_BGR2GRAY)
                        cv.threshold(src, dst, 150, 255, cv.THRESH_BINARY_INV)

                        const contours = new cv.MatVector()
                        const hierarchy = new cv.Mat()
                        cv.findContours(
                            dst,
                            contours,
                            hierarchy,
                            cv.RETR_EXTERNAL,
                            cv.CHAIN_APPROX_SIMPLE
                        )

                        // Get the contour with the largest area (biggest puzzle piece found) and return the center coordinates of the given contour
                        let largestContourMoment, largestContourArea = 0
                        for (let i = 0; i < contours.size(); i++) {
                            const contour = contours.get(i)
                            const moment = cv.moments(contour)
                            if (moment.m00 > largestContourArea) largestContourArea = moment.m00, largestContourMoment = moment
                        }
                        
                        const x = Math.floor(largestContourMoment.m10 / largestContourMoment.m00)
                        const y = Math.floor(largestContourMoment.m01 / largestContourMoment.m00)
                    
                        return {x, y}
                    }

                    const findPuzzlePiecePosition = async () => {
                        try {
                            let [_, puzzle] = await page.$$eval('.geetest_canvas_img canvas', canvases => {
                                return canvases.map(canvas => canvas.toDataURL().replace('data:image/png;base64', ''))
                            })
                        
                            puzzle = await Jimp.read(Buffer.from(puzzle, 'base64'))
    
                            const srcPuzzle = cv.matFromImageData(puzzle.bitmap)
                            const dstPuzzle = new cv.Mat()
                        
                            cv.cvtColor(srcPuzzle, srcPuzzle, cv.COLOR_BGR2GRAY)
                            cv.threshold(srcPuzzle, dstPuzzle, 127, 255, cv.THRESH_BINARY)
                        
                            const kernel = cv.Mat.ones(2, 5, cv.CV_8UC1)
                            const anchor = new cv.Point(-1, -1)
                            cv.dilate(dstPuzzle, dstPuzzle, kernel, anchor, 1)
                            cv.erode(dstPuzzle, dstPuzzle, kernel, anchor, 1)
                        
                            const contours = new cv.MatVector()
                            const hierarchy = new cv.Mat()
                            cv.findContours(
                                dstPuzzle,
                                contours,
                                hierarchy,
                                cv.RETR_EXTERNAL,
                                cv.CHAIN_APPROX_SIMPLE
                            )
                        
                            // Get the contour with the largest area (biggest puzzle piece found) and return the center coordinates of the given contour
                            let largestContourMoment, largestContourArea = 0
                            for (let i = 0; i < contours.size(); i++) {
                                const contour = contours.get(i)
                                const moment = cv.moments(contour)
                                if (moment.m00 > largestContourArea) largestContourArea = moment.m00, largestContourMoment = moment
                            }
                            
                            const x = Math.floor(largestContourMoment.m10 / largestContourMoment.m00)
                            const y = Math.floor(largestContourMoment.m01 / largestContourMoment.m00)
    
                            return {x, y}    
                        } catch (err) {
                            return reject(true)
                        }
                    }
                    
                    // Get the center point of the puzzle piece from the image highlighting differences between the original and captcha image
                    const center = await getPuzzlePiecesSlotCenterPosition(diffImage)

                    // Move the slider to the correct position
                    const sliderHandle = await page.$('.geetest_slider_button')
                    const handle = await sliderHandle.boundingBox()
                
                    let handleX = handle.x + handle.width / 2;
                    let handleY = handle.y + handle.height / 2;
                
                    await page.mouse.move(handleX, handleY, { steps: this.randomInt(25, 100)} );
                    await page.mouse.down();
                
                    let destX = handleX + center.x;
                    let destY = handle.y + handle.height / 3;
                    
                    const randomMovementDelays = (destX, destY) => {

                        const xCoordinateSplitRandoms = Array.from(Array(this.randomInt(30, 50)), () => this.randomFloat(0, 1))
                        const xCoordinateSplitSum = xCoordinateSplitRandoms.reduce((a, b) => a + b)
                        const xCoordinateSplitPercents = xCoordinateSplitRandoms.map(x => x / xCoordinateSplitSum)
                        const xCoordinateSplitParts = xCoordinateSplitPercents.map(x => x * destX)

                        let curX = 0

                        return xCoordinateSplitParts.map(x => ({x: curX += x, y: this.randomInt(0, 1) ? destY + this.randomFloat(15, 30) : destY - this.randomFloat(15, 30)}))
                    }

                    // Geetest checks mouse movements, generate some random mouse movements to vary the positions of the x and y movements, to prevent having a straight line moving the slide captcha
                    for (const movement of randomMovementDelays(destX, destY)) {
                        await page.mouse.move(movement.x, movement.y, { steps: this.randomInt(1, 2) });
                    }
                
                    // The puzzle piece is initialized at a random position, so find the current position and correct it
                    const puzzlePos = await findPuzzlePiecePosition(page)
                    destX = destX + center.x - puzzlePos.x;
                    destY = handle.y + handle.height / 2;
                    await page.waitForTimeout(this.randomInt(50, 250))
                    await page.mouse.move(destX, destY, { steps: this.randomInt(25, 50) })
                    await page.waitForTimeout(this.randomInt(50, 250))
                    await page.mouse.up()
                } catch (err) {
                    return reject(true)
                }
            }

            // Setup an interception on the datadome captcha check endpoint to verify the captcha was solved
            await this.interceptResponse({
                page,
                interception: { url: /captcha\/check/}
            }, async (res) => {
                try {
                    // Reset to default captcha window content once solved
                    await this.interceptRequest({
                        page,
                        interception: { url: /https:\/\/www\.google\.com/, content: DEFAULT_CAPTCHA_WINDOW_CONTENT, contentType: 'text/html' },
                    })

                    await page.goto(DEFAULT_GOOGLE_URL)

                    if (res.statusCode === 200) {
                        const resJSON = JSON.parse(Buffer.from(res.body, 'base64').toString())
                        if (resJSON.cookie) {
                            return resolve(resJSON.cookie)
                        } else return reject(true)
                    } else return reject(true) // Retry on the same solver, if invalid
                } catch (err) {
                    return reject(true)
                }
            })
            
            solveSlide()
        } catch (err) {
            // Don't retry on same solver if error
            return reject(false)
        }    
      })
  }

  /**
   * Wraps a captcha solve function with error handling
   *
   * @function wrapCaptchaSolveWithErrorHandling
   *
   * @param {Function} captchaSolveFunction - Function to solve a captcha
   * @param {Object} parameters - Object with parameters to pass to function call
   */
  wrapCaptchaSolveWithErrorHandling(captchaSolveFunction, parameters) {
    return new Promise(async resolve => {
      try {
        const captchaSolveFunctionWrapper = () => {
          captchaSolveFunction
            .bind(this)(parameters)
            .then(captchaToken => {
              return resolve(captchaToken)
            })
            .catch(err => {
              if (err) {
                captchaSolveFunctionWrapper()
              } else {
                // False makes the captcha be pushed to the beginning of the queue
                return resolve(false)
              }
            })
        }
        captchaSolveFunctionWrapper()
      } catch (err) {
        // False makes the captcha be pushed to the beginning of the queue
        return resolve(false)
      }
    })
  }

  /**
   * Requests a solve for a captcha
   *
   * @function solveCaptcha
   *
   * @param {Object} args - Arguments to request a solve for a captcha
   * @param {"RECAPTCHA_V2_VISIBLE" | "RECAPTCHA_V2_INVISIBLE" | "RECAPTCHA_V3_VISIBLE" | "DATADOME_GEETEST_SLIDE"} args.type - Type of the captcha to be tested
   * @param {string} args.url - Url of the page with a recpatcha
   * @param {?string} args.siteKey - Site key of the page with a recaptcha
   * @param {?string} args.action - Action of an invisible v3 recaptcha
   */
  solveCaptcha({ type, url, siteKey, action }) {
    return new Promise(async (resolve, reject) => {
      try {
        // Find a solver that is available and not in use
        if (this.solvers.some(_solver => _solver.usage.available && !_solver.usage.inUse)) {
          const availableSolvers = this.solvers.filter(_solver => _solver.usage.available & !_solver.usage.inUse)
          const solverInfo = availableSolvers[this.randomInt(0, availableSolvers.length - 1)]
          solverInfo.usage.inUse = true

          let captchaToken

          // Solve the corresponding captcha type
          switch (type) {
            case 'RECAPTCHA_V2_VISIBLE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV2Visible, { solverId: solverInfo.id, url, siteKey })
                break
            case 'RECAPTCHA_V3_INVISIBLE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV3Invisible, { solverId: solverInfo.id, url, siteKey, action })
                break
            case 'RECAPTCHA_V2_INVISIBLE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV2Invisible, { solverId: solverInfo.id, url, siteKey })
                break;
            case 'DATADOME_GEETEST_SLIDE':
                captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveDatadomeGeetestSlide, {solverId: solverInfo.id, url})
                break;
            default:
                return reject()
          }

          solverInfo.usage.inUse = false

          if (captchaToken) {
            // If acquiring a captcha token is successful, notify that the solver is available, and resolve the promise with the captchaToken
            this.emitter.emit('available', solverInfo.id)
            return resolve(captchaToken)
          } else this.queue.unshift({ type, siteKey, url, action, resolve, reject })
        } else this.queue.push({ type, siteKey, url, action, resolve, reject }) // If no solvers are available and not in use, push captcha to end of the captcha queue
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Tests a captcha
   *
   * @function testCaptcha
   *
   * @param {Object} args - Arguments to test a captcha
   * @param {string} args.solverId - Solver to test captcha on
   * @param {"RECAPTCHA_V2_VISIBLE" | "RECAPTCHA_V2_INVISIBLE" | "RECAPTCHA_V3_INVISIBLE"} args.type - Type of the captcha to be tested
   * @param {string} args.url - Url of the page with a recpatcha
   * @param {string} args.siteKey - Site key of the page with a recaptcha
   * @param {?string} args.action - Action of an invisible v3 recaptcha
   */
  testCaptcha({ solverId, type, url, siteKey, action }) {
    return new Promise(async (resolve, reject) => {
      try {
        if (this.solvers.some(_solver => _solver.id === solverId && _solver.usage.available && !_solver.usage.inUse)) {
          const solverInfo = this.solvers.find(solver => solver.id === solverId && solver.usage.available && !solver.usage.inUse)
          solverInfo.usage.inUse = true

          let captchaToken

          // Solve the corresponding captcha type
          switch (type) {
            case 'RECAPTCHA_V2_VISIBLE':
              captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV2Visible, { solverId: solverInfo.id, url, siteKey })
              break
            case 'RECAPTCHA_V3_INVISIBLE':
              captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV3Invisible, { solverId: solverInfo.id, url, siteKey, action })
              break
            case 'RECAPTCHA_V2_INVISIBLE':
              captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveRecaptchaV2Invisible, { solverId: solverInfo.id, url, siteKey, action })
              break
            case 'DATADOME_GEETEST_SLIDE':
              captchaToken = await this.wrapCaptchaSolveWithErrorHandling(this.solveDatadomeGeetestSlide, {solverId: solverInfo.id, url})
              break;
            default:
              return reject()
          }

          solverInfo.usage.inUse = false
          this.emitter.emit('available', solverInfo.id)

          return resolve(captchaToken)
        }
      } catch (err) {
        return reject(err)
      }
    })
  }

  /**
   * Solves a yeezysupply 3DS prompt
   * 
   * @param {Object} args - Arguments to solve a yeezysupply 3DS prompt
   * @param {string} url - The 3DS url
   * @param {string} content - The content fetched from the 3DS url
   * @param {string} user_agent - The user agent used to fetch the 3DS url
   * @param {Object} proxy - The proxy used to fetch the 3DS url
   */
  solveYeezysupply3DS({url, content, user_agent, proxy}) {
      return new Promise(async (resolve, reject) => {
        try {
            // Create the browserview window which has window controls
            const window = new BrowserWindow({
                width: 375,
                height: 650,
                minWidth: 375,
                minHeight: 650,
                maxWidth: 675,
                maxWidth: 375,
                maxHeight: 650,
                webPreferences: {
                  preload: path.join(app.getAppPath(), './main.api.js'),
                  nodeIntegration: false,
                  enableRemoteModule: false,
                  contextIsolation: true,
                },
                show: false,
                backgroundColor: '#191E28',
                frame: false,
                autoHideMenuBar: true,
                darkTheme: true,
                transparent: false
            })
            // Load the window controls
            window.loadURL(this.startUrl('window.html'))
            // Show the window once the window controls have been loaded
            window.webContents.on('did-finish-load', () => window.show())

            // Initialize proxy server used to rotate proxies
            const proxyServer = this.createProxyServer({ port: await getPort() })
            // Create an electron session from a random partition string
            const electronSession = session.fromPartition(this.randomUUIDV4(), { cache: false })
            // Set the session's proxy to the newly created proxy server
            await electronSession.setProxy({ proxyRules: `http://localhost:${proxyServer.port}` })
            // Set the session's proxy to the desired user agent
            electronSession.setUserAgent(user_agent)

            // Create the view with the proxy, and user agent
            const view = new BrowserView({
                webPreferences: {
                    session: electronSession,
                    contextIsolation: true,
                    nodeIntegration: false,
                    enableRemoteModupublicle: false,
                }
            })

            // Must load the default url on the webcontents prior to fetching the page
            await view.webContents.loadURL(`data:text/html,${DEFAULT_CAPTCHA_WINDOW_CONTENT}`)    
            // Add the browserview to the window
            window.addBrowserView(view)

            // Get the puppeteer page object of the added browserview
            const page = (await this.settings.browser.pages())[view.webContents.id - this.viewPageDifference]

            window.on('close', () => {
                return reject()
            })

            // Make the browserview visible, update the bounds to match the new window controls bounds
            view.setBounds({ x: 0, y: 35, width: 375, height: 600 })

            // Rotate the proxy
            proxyServer.rotate(proxy)

            // Setup an interception to intercept the 3ds payment authentication response
            await this.interceptRequest({
                page,
                interception: { stop: true, url: /\/payment\/callback/gmi }
            }, (request) => {
                const formParams = new URLSearchParams(request.postData)

                // Once window is destroyed, resolve with payment authentication response
                window.once('closed', () => {
                    return resolve({
                        PaRes: decodeURIComponent(formParams.get('PaRes'))
                    })
                })

                // Destroy the window
                window.destroy()
            })

            // Setup an interception of the 3ds url to be replaced with the 3ds fetched content
            await this.interceptRequest({
                page,
                interception: { regex: false, url, content, contentType: 'text/html' }
            })

            await page.goto(url)
        } catch (err) {
            return reject(err)
        }
      })
  }

  /**
   * Opens a browser for manual input, given a type
   * 
   * @param {Object} args - Arguments to open a browser
   * @param {'YEEZYSUPPLY_3DS'} args.type - Type of browser to open
   * @param {string} args.url - The 3DS url
   * @param {string} args.content - The content fetched from the 3DS url
   * @param {string} args.user_agent - The user agent used to fetch the 3DS url
   * @param {{host: string, port: number, username: string | undefined, password: string | undefined}} args.proxy - The proxy used to fetch the 3DS url
   */
  openBrowser({type, url, content, user_agent, proxy}) {
    switch (type) {
        case 'YEEZYSUPPLY_3DS':
            return this.solveYeezysupply3DS({url, content, user_agent, proxy})
    }
  }

  getSolveCaptcha = () => this.solveCaptcha.bind(this)

  getOpenBrowser = () => this.openBrowser.bind(this)
}

function getChromiumExecPath() {
  return puppeteer.executablePath().replace('app.asar', 'app.asar.unpacked');
}